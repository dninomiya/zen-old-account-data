---
title: "Firestoreにセキュリティルールを設定する"
free: false
---

# Firestore セキュリティルールとは

Firestoreのセキュリティルールは誰がどの情報にアクセスするかの条件、制限を指します。最終的なセキュリティの要（最終門番）なので、セキュリティルールが緩いと重要なデータが流出してしまいます。逆に必要なリクエストについては制限を解放しないと情報が取得できません。

Firestore セキュリティルールは**許可制**です。基本的にすべてのリクエストをブロックしつつ、「特定のルールに従えばリクエストを特別に許可するよ。」という世界観になります。

前回作成した認証コンテクストの中で、以下のタイミングでFirestoreと通信を行なっています。

- ログインしたユーザーのデータをFirestoreから読み込む
- ユーザーデータが存在しない場合、Firestoreにユーザーデータを作成する

最初にFirebaseプロジェクトのFirestoreを初期化した際、ルールを本番モードにしているのでこれらのリクエストは許可されておらず、権限エラーで弾かれます。そこで今回はルールを設定し、上記のリクエストが通るようにします。

:::details 本番モードとは
本番モードはすべてのリクエストを禁止した状態でルールが初期化されています。逆にテストモードはすべてのリクエストが許可された状態でルールが初期化されています。テストモードは時間制限で全禁止モードに移行しますが、ルール設定漏れが後で発覚してリリースに影響するリスクがあるので最初から本番モードを選ぶことをおすすめしましょう。
:::

## セキュリティルールはFirebase管理コンソールから設定可能

まず、Firestore セキュリティルールをはじめFirebaseにはさまざまな設定や実装が存在します。

- Firebase Hosting
- Cloud Firestoreのルール、インデックス
- Cloud Storageのルール
- Cloud Functionsの実装

一般的にはFirebaseの開発、設定環境をローカルに用意し、実装したものをFirebaseにデプロイして反映させます。ただ、ルール系の設定に関してはそのようなプロセスを踏まなくともFirebaseの管理コンソールからオンラインでルールを設定することができます。

チームでルールをGit管理したい場合や、ルールが極めて複雑かつ膨大になる場合を除いて、ルールは管理コンソールからでも問題ありません。管理コンソールからルール設定を行う場合以下のメリットがあります。

- テストを事前にテストできる
- コードがハイライトされる
- バージョン管理が搭載されており、すぐにロールバック（古いバージョンに戻すこと）ができる
- ローカルでルールを管理する必要がないのでメンテナンス構造がシンプルになる

なお、Next.jsの場合**ほとんどの読み込みリクエストはNext.jsのサーバーサイドから**行われます。サーバーサイドはFirebase Admin SDKを使ってFirestoreにアクセスしますが、Admin SDKは**ルールの影響を受けません**。したがって読み込みに関しては基本的にルールを設定する必要がなく、ルールが肥大化しにくいという背景もあります。

今回はFirebase管理コンソールからルールを設定することになります。ローカルであろうが管理コンソールであろうが基本的に記述は変わらないので、ローカル環境に興味のある方は[公式ドキュメント](https://firebase.google.com/docs/firestore/security/get-started?hl=ja#use_the_firebase_cli)をご参照ください。

# ルールを設定する

おさらいすると、今回は以下の二つのリクエストについて許可される必要があります。

- ログインしたユーザーのデータをFirestoreから読み込む
- ユーザーデータが存在しない場合、Firestoreにユーザーデータを作成する

ルールは以下のようになります。

```js
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    match /users/{uid} {
      allow read, write: if request.auth != null && request.auth.uid == uid;
    }
  }
}
```

以下の部分がルールを設定する対象のドキュメントになります。この場合 `users` コレクションの中にあるドキュメントに対しルールを設定しています。 `{uid}` の部分はドキュメントIDが入ります。 `{}` の中身は変数としてキャッシュされるので、ルールの中で使うことができます。

```js
match /users/{uid} {
  ...
}
```

以下の部分はルールを設定するリクエストの種類です。

```js
allow read, write
```

今回は　read=読み込み、write=書き込み　のみですがより詳細に指定することも可能です。

グループ|詳細な指定|意味
---|---|---
read|get|ドキュメントの取得
read|list|ドキュメント一覧の取得
write|create|ドキュメントの作成
write|update|ドキュメントの更新
write|delete|ドキュメントの削除

readやwriteはグループに属する指定をまとめて行なっていることになります。

以下の部分がルール（許可する条件）になります。

```js
if request.auth != null && request.auth.uid == uid;
```

`request.auth` はログイン中ユーザーの認証情報が入ります。したがって `request.auth != null` はログインしているユーザーであればパスすることができます。 `request.auth.uid == uid` はログインユーザーの認証IDと、これからリクエストしようとするドキュメントのIDを照合しています。

IDの照合を行わない場合、ログインさえしていれば他の人のユーザーデータを無制限に取得、改ざんできてしまいます。あくまで自分のドキュメントしか取得、更新できないようにしています。 `uid` の部分はパスでキャッシュされたドキュメントのIDが入ります。

![](https://storage.googleapis.com/zenn-user-upload/fe7598d6f9ef-20211126.jpeg)
*イメージ*

# ルールのテスト

それでは実際にルールをテストしてみましょう。ルールエディター左下にある[ルールプレイグラウンド]をクリックし、以下の内容を入力して実行してください。場所の部分に `users/xxx` と入力しているので、ID `xxx` さんのドキュメントを `get` で読み出そうとしている状態を再現しています。

![](https://storage.googleapis.com/zenn-user-upload/a03391a42f7c-20211126.png)

実行すると画面のようにエラーが出たことがわかります。これはログインしてない状態でリクエストをしたので、 `request.auth != null` の部分で弾かれたためです。

次に[認証済み]にチェックを入れて再度実行してみましょう。

![](https://storage.googleapis.com/zenn-user-upload/e6ef44e4c228-20211126.png)

再度エラーが発生しました。これはログインはしているが、アクセス対象のドキュメントIDと認証ユーザーのIDが一致しないため、`request.auth.uid == uid` の照合で弾かれたためです。

たとえるなら「マイナンバーxxxさんの個人情報」を、「マイナンバーがxxxではない人」が不正に取得しようとした状態です。それではログインしている人の認証IDを `xxx` に変更して再度実行してみましょう。

![](https://storage.googleapis.com/zenn-user-upload/0d54dc0032d2-20211126.png)

今度は成功したことが分かります。最後に忘れずルールを公開してください。公開されないとルールが適用されません。

![](https://storage.googleapis.com/zenn-user-upload/d9377694b844-20211126.png)

以上でセキュリティルールの設定は終了です。以後同様のプロセスでルールのテストと設定を行います。最初に述べたようにFirestore セキュリティルールは許可制なので、現状はログイン中のユーザーが自分のユーザーデータを読み書きする以外、一切のFirestore通信が認められていない状態です。